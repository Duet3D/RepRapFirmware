/*
 * LinuxInterface.cpp
 *
 *  Created on: 29 Mar 2019
 *      Author: Christian
 */

#include "LinuxInterface.h"
#include "DataTransfer.h"

#include "GCodes/GCodeBuffer/GCodeBuffer.h"
#include "GCodes/GCodes.h"
#include "Platform.h"
#include "PrintMonitor.h"
#include "Tools/Filament.h"
#include "RepRap.h"
#include "RepRapFirmware.h"
#include <Hardware/Cache.h>

#if HAS_LINUX_INTERFACE

LinuxInterface::LinuxInterface() : transfer(new DataTransfer()), wasConnected(false), numDisconnects(0),
	reportPause(false), rxPointer(0), txPointer(0), txLength(0), sendBufferUpdate(true),
	iapWritePointer(IAP_IMAGE_START), gcodeReply(new OutputStack())
{
}

void LinuxInterface::Init()
{
	transfer->Init();
	transfer->StartNextTransfer();
}

void LinuxInterface::Spin()
{
	if (transfer->IsReady())
	{
		// Process incoming packets
		for (size_t i = 0; i < transfer->PacketsToRead(); i++)
		{
			const PacketHeader *packet = transfer->ReadPacket();
			if (packet == nullptr)
			{
				if (reprap.Debug(moduleLinuxInterface))
				{
					reprap.GetPlatform().Message(DebugMessage, "Error trying to read next SPI packet\n");
				}
				break;
			}

			if (packet->request >= (uint16_t)LinuxRequest::InvalidRequest)
			{
				REPORT_INTERNAL_ERROR;
				return;
			}
			const LinuxRequest request = (LinuxRequest)packet->request;

			switch (request)
			{
			// Perform an emergency stop
			case LinuxRequest::EmergencyStop:
				reprap.EmergencyStop();
				break;

			// Reset the controller
			case LinuxRequest::Reset:
				reprap.SoftwareReset((uint16_t)SoftwareResetReason::user);
				return;

			// Perform a G/M/T-code
			case LinuxRequest::Code:
			{
				// Check if the code overlaps. If so, restart from the beginning
				if (txPointer + sizeof(BufferedCodeHeader) + packet->length > SpiCodeBufferSize)
				{
					if (rxPointer == txPointer)
					{
						rxPointer = 0;
					}
					txLength = txPointer;
					txPointer = 0;
					sendBufferUpdate = true;
				}

				// Store the buffer header
				BufferedCodeHeader *bufHeader = reinterpret_cast<BufferedCodeHeader*>(codeBuffer + txPointer);
				bufHeader->isPending = true;
				bufHeader->length = packet->length;
				txPointer += sizeof(BufferedCodeHeader);

				// Store the code content
				size_t dataLength = packet->length;
				memcpy(codeBuffer + txPointer, transfer->ReadData(packet->length), dataLength);
				txPointer += dataLength;
				break;
			}

			// Get the object model of a specific module (TODO report real object model here instead of status responses)
			case LinuxRequest::GetObjectModel:
			{
				uint8_t module = transfer->ReadGetObjectModel();
				OutputBuffer *buffer = (module != 5)
						? reprap.GetStatusResponse(module, ResponseSource::Generic)
								: reprap.GetConfigResponse();
				if (buffer != nullptr && !transfer->WriteObjectModel(module, buffer))
				{
					// Failed to write the whole object model, try again later
					transfer->ResendPacket(packet);
					OutputBuffer::ReleaseAll(buffer);
				}
				break;
			}

			// Set value in the object model
			case LinuxRequest::SetObjectModel:
			{
				size_t dataLength = packet->length;
				const char *data = transfer->ReadData(dataLength);
				// TODO implement this
				(void)data;
				break;
			}

			// Print has been started, set file print info
			case LinuxRequest::PrintStarted:
			{
				String<MaxFilenameLength> filename;
				StringRef filenameRef = filename.GetRef();
				transfer->ReadPrintStartedInfo(packet->length, filenameRef, fileInfo);
				reprap.GetPrintMonitor().SetPrintingFileInfo(filename.c_str(), fileInfo);
				reprap.GetGCodes().StartPrinting(true);
				break;
			}

			// Print has been stopped
			case LinuxRequest::PrintStopped:
			{
				const PrintStoppedReason reason = transfer->ReadPrintStoppedInfo();
				if (reason == PrintStoppedReason::normalCompletion)
				{
					// Just mark the print file as finished
					GCodeBuffer *gb = reprap.GetGCodes().GetGCodeBuffer(GCodeChannel::file);
					gb->SetPrintFinished();
				}
				else
				{
					// Stop the print with the given reason
					reprap.GetGCodes().StopPrint((StopPrintReason)reason);
					InvalidateBufferChannel(GCodeChannel::file);
				}
				break;
			}

			// Macro file has been finished
			case LinuxRequest::MacroCompleted:
			{
				GCodeChannel channel;
				bool error;
				transfer->ReadMacroCompleteInfo(channel, error);

				GCodeBuffer *gb = reprap.GetGCodes().GetGCodeBuffer(channel);
				gb->MachineState().SetFileFinished(error);

				if (reprap.Debug(moduleLinuxInterface))
				{
					reprap.GetPlatform().MessageF(DebugMessage, "Macro completed on channel %d\n", (int)channel);
				}
				break;
			}

			// Return heightmap as generated by G29 S0
			case LinuxRequest::GetHeightMap:
			{
				if (!transfer->WriteHeightMap())
				{
					// Failed to write the whole heightmap, try again later
					transfer->ResendPacket(packet);
				}
				break;
			}

			// Set heightmap via G29 S1
			case LinuxRequest::SetHeightMap:
				transfer->ReadHeightMap();
				break;

			// Lock movement and wait for standstill
			case LinuxRequest::LockMovementAndWaitForStandstill:
			{
				GCodeChannel channel;
				transfer->ReadLockUnlockRequest(channel);
				GCodeBuffer *gb = reprap.GetGCodes().GetGCodeBuffer(channel);
				if (reprap.GetGCodes().LockMovementAndWaitForStandstill(*gb))
				{
					transfer->WriteLocked(channel);
				}
				else
				{
					transfer->ResendPacket(packet);
				}
				break;
			}

			// Unlock everything
			case LinuxRequest::Unlock:
			{
				GCodeChannel channel;
				transfer->ReadLockUnlockRequest(channel);
				GCodeBuffer *gb = reprap.GetGCodes().GetGCodeBuffer(channel);
				reprap.GetGCodes().UnlockAll(*gb);
				break;
			}

			// Write another chunk of the IAP binary to the designated Flash area
			case LinuxRequest::WriteIap:
#if IAP_IN_RAM
				memcpy(reinterpret_cast<char *>(iapWritePointer), transfer->ReadData(packet->length), packet->length);
				iapWritePointer += packet->length;
				break;
#else
			{
				if (iapWritePointer == IAP_IMAGE_START)
				{
					// The EWP command is not supported for non-8KByte sectors in the SAM4 and SAME70 series.
					// So we have to unlock and erase the complete 64Kb or 128kb sector first. One sector is always enough to contain the IAP.
					flash_unlock(IAP_IMAGE_START, IAP_IMAGE_END, nullptr, nullptr);
					flash_erase_sector(IAP_IMAGE_START);
				}
				const char *dataToWrite = transfer->ReadData(packet->length);
				size_t bytesWritten = 0;
				do
				{
					size_t bytesToWrite = min<size_t>(IFLASH_PAGE_SIZE, packet->length - bytesWritten), retry = 0;
					do
					{
						// Write one page at a time
						cpu_irq_disable();
						const uint32_t rc = flash_write(iapWritePointer, dataToWrite, bytesToWrite, 0);
						cpu_irq_enable();

						if (rc != FLASH_RC_OK)
						{
							reprap.GetPlatform().MessageF(FirmwareUpdateErrorMessage, "flash write failed, code=%" PRIu32 ", address=0x%08" PRIx32 "\n", rc, iapWritePointer);
							return;
						}

						// Verify written data
						if (memcmp(reinterpret_cast<void *>(iapWritePointer), dataToWrite, bytesToWrite) == 0)
						{
							break;
						}
						reprap.GetPlatform().MessageF(FirmwareUpdateErrorMessage, "verify during flash write failed, address=0x%08" PRIx32 "\n", iapWritePointer);
					} while (retry++ < 3);

					// Stop on error
					if (retry == 3)
					{
						break;
					}

					// Move on to the next chunk
					bytesWritten += bytesToWrite;
					dataToWrite += bytesToWrite;
					iapWritePointer += bytesToWrite;
				} while (bytesWritten != packet->length);
				break;
			}
#endif

			// Launch the IAP binary
			case LinuxRequest::StartIap:
				reprap.EmergencyStop();			// turn off heaters etc.
				Cache::Disable();				// this also flushes the data cache
#if USE_MPU
				//TODO consider setting flash memory to strongly-ordered instead
				ARM_MPU_Disable();
#endif

#if !IAP_IN_RAM
				// Lock the whole IAP flash area again and start the IAP binary
				flash_lock(IAP_IMAGE_START, IAP_IMAGE_END, nullptr, nullptr);
#endif
				reprap.StartIap();
				break;

			// Assign filament
			case LinuxRequest::AssignFilament:
			{
				int extruder;
				String<FilamentNameLength> filamentName;
				StringRef filamentRef = filamentName.GetRef();
				transfer->ReadAssignFilament(extruder, filamentRef);

				Filament *filament = Filament::GetFilamentByExtruder(extruder);
				if (filament != nullptr)
				{
					if (filamentName.IsEmpty())
					{
						filament->Unload();
					}
					else
					{
						filament->Load(filamentName.c_str());
					}
				}
				break;
			}

			// Return a file chunk
			case LinuxRequest::FileChunk:
				transfer->ReadFileChunk(requestedFileChunk, requestedFileDataLength, requestedFileLength);
				requestedFileSemaphore.Give();
				break;

			// Invalid request
			default:
				REPORT_INTERNAL_ERROR;
				break;
			}
		}

		// Send code replies and generic messages
		while (!gcodeReply->IsEmpty())
		{
			MessageType type = gcodeReply->GetFirstItemType();
			OutputBuffer *buffer = gcodeReply->GetFirstItem();
			if (buffer == nullptr)
			{
				// This is an empty response
				if (!transfer->WriteCodeReply(type, buffer))
				{
					break;
				}
				(void)gcodeReply->Pop();
			}
			else
			{
				// This response contains data
				if (!transfer->WriteCodeReply(type, buffer))
				{
					break;
				}
				gcodeReply->SetFirstItem(buffer);
			}
		}

		// Notify DSF about the available buffer space
		if (sendBufferUpdate || transfer->LinuxHadReset())
		{
			uint16_t bufferSpace = (txLength == 0) ? max<uint16_t>(rxPointer, SpiCodeBufferSize - txPointer) : rxPointer - txPointer;
			sendBufferUpdate = !transfer->WriteCodeBufferUpdate(bufferSpace);
		}

		// Get another chunk of the file being requested
		if (!requestedFileName.IsEmpty() && !reprap.GetGCodes().IsFlashing() &&
			transfer->WriteFileChunkRequest(requestedFileName.c_str(), requestedFileOffset, requestedFileLength))
		{
			requestedFileName.Clear();
		}

		// Deal with code channel requests
		bool reportMissing, fromCode;
		for (size_t i = 0; i < NumGCodeChannels; i++)
		{
			const GCodeChannel channel = (GCodeChannel)i;
			GCodeBuffer *gb = reprap.GetGCodes().GetGCodeBuffer(channel);

			// Invalidate buffered codes if required
			if (gb->IsInvalidated())
			{
				InvalidateBufferChannel(gb->GetChannel());
				gb->Invalidate(false);
			}

			// Handle macro start requests
			const char *requestedMacroFile = gb->GetRequestedMacroFile(reportMissing, fromCode);
			if (requestedMacroFile != nullptr && transfer->WriteMacroRequest(channel, requestedMacroFile, reportMissing, fromCode))
			{
				if (reprap.Debug(moduleLinuxInterface))
				{
					reprap.GetPlatform().MessageF(DebugMessage, "Requesting macro file '%s' (reportMissing: %s fromCode: %s)\n", requestedMacroFile, reportMissing ? "true" : "false", fromCode ? "true" : "false");
				}
				gb->RequestMacroFile(nullptr, reportMissing, fromCode);
				gb->Invalidate();
			}

			// Handle file abort requests
			if (gb->IsAbortRequested() && transfer->WriteAbortFileRequest(channel, gb->IsAbortAllRequested()))
			{
				gb->AcknowledgeAbort();
				gb->Invalidate();
			}

			// Report stack levels when RRF detects a DSF reset
			if (transfer->LinuxHadReset())
			{
				gb->ReportStack();
			}

			// Send stack details to DSF. May be replaced by the Object Model at some point
			if (gb->IsStackEventFlagged() && transfer->WriteStackEvent(channel, gb->MachineState()))
			{
				gb->AcknowledgeStackEvent();
			}
		}

		// Send pause notification on demand
		if (reportPause && transfer->WritePrintPaused(pauseFilePosition, pauseReason))
		{
			reportPause = false;
			reprap.GetGCodes().GetGCodeBuffer(GCodeChannel::file)->Invalidate();
		}

		// Start the next transfer
		transfer->StartNextTransfer();
		if (!wasConnected)
		{
			reprap.GetPlatform().Message(NetworkInfoMessage, "Connection to Linux established!\n");
		}
		wasConnected = true;
	}
	else if (!transfer->IsConnected())
	{
		if (wasConnected)
		{
			reprap.GetPlatform().Message(NetworkInfoMessage, "Lost connection to Linux\n");

			wasConnected = false;
			numDisconnects++;

			rxPointer = txPointer = txLength = 0;
			sendBufferUpdate = true;
			iapWritePointer = IAP_IMAGE_START;

			if (!requestedFileName.IsEmpty())
			{
				requestedFileDataLength = -1;
				requestedFileSemaphore.Give();
			}

			// Don't cache any messages if they cannot be sent
			gcodeReply->ReleaseAll();

			// Close all open G-code files
			for (size_t i = 0; i < NumGCodeChannels; i++)
			{
				GCodeBuffer *gb = reprap.GetGCodes().GetGCodeBuffer((GCodeChannel)i);
				gb->AbortFile(true, false);
				gb->MessageAcknowledged(true);
			}
			reprap.GetGCodes().StopPrint(StopPrintReason::abort);
		}

		// Invalidate the G-code buffers holding binary data (if applicable)
		for (size_t i = 0; i < NumGCodeChannels; i++)
		{
			GCodeBuffer *gb = reprap.GetGCodes().GetGCodeBuffer((GCodeChannel)i);
			if (gb->IsBinary() && gb->IsCompletelyIdle())
			{
				gb->Reset();
			}
		}
	}
}

void LinuxInterface::Diagnostics(MessageType mtype)
{
	reprap.GetPlatform().Message(mtype, "=== Linux interface ===\n");
	transfer->Diagnostics(mtype);
	reprap.GetPlatform().MessageF(mtype, "Number of disconnects: %" PRIu32 "\n", numDisconnects);
	reprap.GetPlatform().MessageF(mtype, "Buffer RX/TX: %d/%d-%d\n", (int)rxPointer, (int)txPointer, (int)txLength);
}

bool LinuxInterface::FillBuffer(GCodeBuffer &gb)
{
	if (gb.IsInvalidated() || gb.IsMacroRequested() || gb.IsAbortRequested() || (reportPause && gb.GetChannel() == GCodeChannel::file))
	{
		// Don't interpret codes that are supposed to be suspended...
		return false;
	}

	if (rxPointer != txPointer || txLength != 0)
	{
		bool updateRxPointer = true;
		uint16_t readPointer = rxPointer;
		do
		{
			BufferedCodeHeader *bufHeader = reinterpret_cast<BufferedCodeHeader*>(codeBuffer + readPointer);
			readPointer += sizeof(BufferedCodeHeader);
			const CodeHeader *header = reinterpret_cast<const CodeHeader*>(codeBuffer + readPointer);
			readPointer += bufHeader->length;

			if (bufHeader->isPending)
			{
				if (gb.GetChannel() == header->channel)
				{
					gb.PutAndDecode(reinterpret_cast<const char *>(header), bufHeader->length, true);
					bufHeader->isPending = false;

					if (updateRxPointer)
					{
						sendBufferUpdate = true;

						rxPointer = readPointer;
						if (rxPointer == txLength)
						{
							rxPointer = txLength = 0;
						}
						else if (rxPointer == txPointer && txLength == 0)
						{
							rxPointer = txPointer = 0;
						}
					}

					return true;
				}
				else
				{
					updateRxPointer = false;
				}
			}

			if (readPointer == txLength)
			{
				readPointer = 0;
			}
		} while (readPointer != txPointer);
	}
	return false;
}

// Read a file chunk from the SBC. When a response has been received, the current thread is woken up again.
// If an error occurred, the number of bytes read is -1
const char *LinuxInterface::GetFileChunk(const char *filename, uint32_t offset, uint32_t maxLength, int32_t& dataLength, uint32_t& fileLength)
{
	requestedFileName.copy(filename);
	requestedFileLength = min<uint32_t>(maxLength, MaxFileChunkSize);
	requestedFileOffset = offset;

	requestedFileSemaphore.Take();

	dataLength = requestedFileDataLength;
	fileLength = requestedFileLength;
	return requestedFileChunk;
}

void LinuxInterface::HandleGCodeReply(MessageType mt, const char *reply)
{
	if (!transfer->IsConnected())
	{
		return;
	}

	OutputBuffer *buffer = gcodeReply->GetLastItem();
	if (buffer != nullptr && mt == gcodeReply->GetLastItemType() && (mt & PushFlag) != 0 && !buffer->IsReferenced())
	{
		// Try to save some space by combining segments that have the Push flag set
		buffer->cat(reply);
	}
	else if (reply[0] != 0 && OutputBuffer::Allocate(buffer))
	{
		// Attempt to allocate one G-code buffer per non-empty output message
		buffer->cat(reply);
		gcodeReply->Push(buffer, mt);
	}
	else
	{
		// Store nullptr to indicate an empty response. This way many OutputBuffer references can be saved
		gcodeReply->Push(nullptr, mt);
	}
}

void LinuxInterface::HandleGCodeReply(MessageType mt, OutputBuffer *buffer)
{
	if (!transfer->IsConnected())
	{
		OutputBuffer::ReleaseAll(buffer);
		return;
	}

	gcodeReply->Push(buffer, mt);
}

void LinuxInterface::InvalidateBufferChannel(GCodeChannel channel)
{
	if (rxPointer != txPointer || txLength != 0)
	{
		bool updateRxPointer = true;
		uint16_t readPointer = rxPointer;
		do
		{
			BufferedCodeHeader *bufHeader = reinterpret_cast<BufferedCodeHeader*>(codeBuffer + readPointer);
			readPointer += sizeof(BufferedCodeHeader);

			if (bufHeader->isPending)
			{
				const CodeHeader *header = reinterpret_cast<const CodeHeader*>(codeBuffer + readPointer);
				if (header->channel == channel)
				{
					bufHeader->isPending = false;
				}
				else
				{
					updateRxPointer = false;
				}
			}
			readPointer += bufHeader->length;

			if (readPointer == txLength)
			{
				readPointer = 0;
			}

			if (updateRxPointer)
			{
				sendBufferUpdate = true;
				rxPointer = readPointer;
				if (rxPointer == 0)
				{
					txLength = 0;
				}
				else if (rxPointer == txPointer && txLength == 0)
				{
					rxPointer = txPointer = 0;
					break;
				}
			}
		} while (readPointer != txPointer);

		// TODO It might make sense to reorder out-of-order blocks here to create a larger chunk of free buffer space.
		// An alternative could be to limit the buffered codes per size per channel in DCS - yet we must avoid segmentation as much as possible
		// Segmentation could become a problem if a lot of codes from different channels keep coming in and one or more codes cannot be put into GB(s)
	}
}

#endif
